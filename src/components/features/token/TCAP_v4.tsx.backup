import { useEffect, useState, forwardRef, useImperativeHandle, useCallback, useMemo } from 'react';
import { ethers, Contract, BrowserProvider } from 'ethers';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Spinner } from '@/components/ui/Spinner';
import { useToast } from '@/components/ui/toast/use-toast';
import { getNetworkContractAddress } from '@/config/contracts';
import { getExplorerUrl } from '@/config/networks';
import { shortenAddress } from '@/utils/address';
import { Dialog, DialogContent, DialogTitle, DialogDescription } from "@/components/ui/dialog";
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import { ChevronDown, ChevronUp, ExternalLink, Settings, Eye, EyeOff } from 'lucide-react';
import { RefreshCw } from 'lucide-react';
import { Input } from '@/components/ui/input';
import { useAccount } from 'wagmi';
import { formatEther, formatUnits, parseUnits } from 'ethers';
import { contractRegistry } from '@/config/contracts';
import { NetworkId } from '@/config/networks';
import { NETWORK_CONFIG } from '@/config/networks';

// Define ABIs here
// Token Contract ABI - expanded version for better compatibility
const TokenABI = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function totalSupply() view returns (uint256)",
  "function balanceOf(address) view returns (uint256)",
  "function transfer(address to, uint256 amount) returns (bool)",
  "function owner() view returns (address)",
  "function getOwner() view returns (address)",   // Some tokens use getOwner instead of owner
  "function getModules() view returns (address[])",
  "function modules(uint256) view returns (address)",  // For array-style modules
  "function getLiquidityModule() view returns (address)",
  "function liquidityModule() view returns (address)",  // Alternative naming
  "function getDistributionModule() view returns (address)",
  "function distributionModule() view returns (address)", // Alternative naming
  "function getLiquidityAllocation() view returns (uint256)",
  "function getSecurityModule() view returns (address)" 
];

// Factory ABI - updated for V4 factory with distribution
const FactoryABI = [
  "function createToken(string,string,uint256,address) returns (address)",
  "function createTokenForWeb(string,string,uint256,address,bool) returns (address)",
  "function createTokenWithSecurity(string,string,uint256,address,bool,address[],uint256) returns (address)",
  "function createTokenWithDistribution(string,string,uint256,address,bool,address[],uint256,tuple(address,uint256)[]) returns (address)",
  "function getTokenImplementation() view returns (address)",
  "function getSecurityModuleImplementation() view returns (address)",
  "function getDistributionModuleImplementation() view returns (address)",
  "function getLiquidityModuleImplementation() view returns (address)",
  "function getAllTokens() view returns (address[])",
  "function getUserCreatedTokens(address) view returns (address[])",
  "function getUserTokens(address) view returns (address[])",
  "function upgradeTokenImplementation(address) returns (bool)",
  "function upgradeSecurityModuleImplementation(address) returns (bool)",
  "function upgradeDistributionModuleImplementation(address) returns (bool)",
  "function upgradeLiquidityModuleImplementation(address) returns (bool)",
  "event TokenCreated(address indexed tokenAddress, string name, string symbol, address indexed owner)",
  "event TokenDeployed(address indexed tokenAddress, string name, string symbol, address indexed owner)",
  "event LiquidityAdded(address indexed tokenAddress, address indexed pair, uint256 tokenAmount, uint256 ethAmount)",
  "event DeploymentInfo(address indexed tokenAddress, address indexed owner, address[] modules)",
  "event DistributionSetup(address indexed tokenAddress, address indexed distributionModule, tuple(address,uint256)[] allocations)"
];

// Safe helper function 
const safeGetExplorerUrl = (chainId: number | undefined, address: string, type: "address" | "token" | "tx" = "address"): string => {
  if (!chainId) return '#'; // Return a safe default
  return getExplorerUrl(chainId, address, type);
};

// Function to check if a chainId corresponds to Polygon Amoy network
function isPolygonAmoyNetwork(chainId: number): boolean {
  return chainId === 80002;
}

// Function to identify special tokens with reserved liquidity
// This will be called with token contracts, not just addresses
const isSpecialReservedToken = async (tokenAddress: string, provider: any): Promise<boolean> => {
  try {
    if (!provider || !tokenAddress) return false;
    
    // Explicitly check for the STSEV token address
    if (tokenAddress.toLowerCase() === process.env.NEXT_PUBLIC_STSEV_TOKEN_ADDRESS?.toLowerCase()) {
      console.log("STSEV token detected - enabling special liquidity handling with 400k allocation");
      return true;
    }
    
    const signer = await provider.getSigner();
    const tokenContract = new Contract(
      tokenAddress,
      [
        'function balanceOf(address) view returns (uint256)',
        'function decimals() view returns (uint8)',
        'function getDistributionModule() view returns (address)',
        'function distributionModule() view returns (address)',
        'function getLiquidityAllocation() view returns (uint256)',
        'function liquidityAllocation() view returns (uint256)'
      ],
      signer
    );
    
    // Check for allocation or contract balance indicators
    try {
      // Check decimals
      const decimals = await tokenContract.decimals().catch(() => 18);
      
      // Try different methods to get the liquidity allocation
      let liquidityAllocation = BigInt(0);
      try {
        liquidityAllocation = await tokenContract.getLiquidityAllocation().catch(async () => {
          return await tokenContract.liquidityAllocation().catch(() => BigInt(0));
        });
      } catch (e) {
        console.log("Direct liquidity allocation check failed");
      }
      
      // If we found a liquidity allocation
      if (liquidityAllocation > BigInt(0)) {
        // Check if it's at least 1k tokens (assuming 18 decimals)
        const significantAmount = ethers.parseUnits("1000", decimals);
        if (liquidityAllocation >= significantAmount) {
          console.log(`Token ${tokenAddress} has significant liquidity allocation: ${liquidityAllocation}`);
          return true;
        }
      }
      
      // Check if the token has a distribution module with allocation
      try {
        let distributionModule = null;
        try {
          distributionModule = await tokenContract.getDistributionModule().catch(async () => {
            return await tokenContract.distributionModule().catch(() => null);
          });
        } catch (e) {
          console.log("Distribution module check failed");
        }
        
        if (distributionModule && distributionModule !== ethers.ZeroAddress) {
          const distributionContract = new Contract(
            distributionModule,
            [
              'function getLiquidityAllocation() view returns (uint256)',
              'function liquidityAllocation() view returns (uint256)'
            ],
            signer
          );
          
          try {
            liquidityAllocation = await distributionContract.getLiquidityAllocation().catch(async () => {
              return await distributionContract.liquidityAllocation().catch(() => BigInt(0));
            });
            
            // Check if it's at least 1k tokens
            const significantAmount = ethers.parseUnits("1000", decimals);
            if (liquidityAllocation >= significantAmount) {
              console.log(`Token ${tokenAddress} has significant liquidity allocation in distribution module: ${liquidityAllocation}`);
              return true;
            }
          } catch (e) {
            console.log("Distribution module liquidity allocation check failed");
          }
        }
      } catch (e) {
        console.log("Distribution module checks failed entirely");
      }
      
      // Check contract balance as last resort
      try {
        // Check the token's own balance - if token holds itself, that's intended for liquidity
        const contractBalance = await tokenContract.balanceOf(tokenAddress);
        const significantAmount = ethers.parseUnits("1000", decimals);
        if (contractBalance >= significantAmount) {
          console.log(`Token ${tokenAddress} has significant self-balance: ${contractBalance}`);
          return true;
        }
      } catch (e) {
        console.log("Contract balance check failed");
      }
      
      // Try checking if tokens are held by any factory addresses
      try {
        // Check known factory addresses for token balances
        const factoryAddresses = [
          process.env.NEXT_PUBLIC_POLYGONAMOY_FACTORY_ADDRESS_V4_WITH_LIQUIDITY_FIXED_V7 || '0x0000000000000000000000000000000000000000', // V7 factory
          process.env.NEXT_PUBLIC_POLYGONAMOY_FACTORY_ADDRESS_V4_WITH_LIQUIDITY_FIXED_V6 || '0x0000000000000000000000000000000000000000', // V6 factory
          process.env.NEXT_PUBLIC_POLYGONAMOY_FACTORY_ADDRESS_V4_WITH_LIQUIDITY_FIXED_V5 || '0x0000000000000000000000000000000000000000'  // V5 factory
        ];
        
        for (const factoryAddress of factoryAddresses) {
          try {
            const factoryBalance = await tokenContract.balanceOf(factoryAddress);
            const significantAmount = ethers.parseUnits("1000", decimals);
            if (factoryBalance >= significantAmount) {
              console.log(`Factory ${factoryAddress} holds significant token balance: ${factoryBalance}`);
              return true;
            }
          } catch (e) {
            console.log(`Failed to check balance for factory ${factoryAddress}`);
          }
        }
      } catch (e) {
        console.log("Factory balance checks failed");
      }
    } catch (error) {
      console.error("Error in special token detection:", error);
    }
    
    return false;
  } catch (e) {
    console.error("Error in isSpecialReservedToken:", e);
    return false;
  }
};

export interface TCAP_v4Props {
  isConnected: boolean;
  address?: string;
  provider: any;
}

interface TokenInfo {
  address: string;
  name: string;
  symbol: string;
  totalSupply: string;
  owner: string;
  createdAt?: number;
  // Add liquidity related information
  pairAddress?: string;
  liquidityInfo?: {
    pair?: string;
    token0?: string;
    token1?: string;
    reserve0?: string;
    reserve1?: string;
    lpTokenBalance?: string;
    locked?: boolean;
    lockDuration?: number;
    unlockTime?: number;
  };
  // Distribution model
  distribution?: {
    liquidityAllocation?: string; // Amount of tokens reserved for liquidity in the contract
    marketingAllocation?: string;
    teamAllocation?: string;
    treasuryAllocation?: string;
  };
  decimals?: number;
  userBalance?: string;
  chainId?: number;
  // Add tokenomics related fields
  paused?: boolean;
  antiDumpEnabled?: boolean;
  buyTaxRate?: number;
  sellTaxRate?: number;
  dynamicTaxEnabled?: boolean;
  maxTxAmount?: string;
  maxWalletAmount?: string;
  modules?: string[];
}

export interface TCAP_v4Ref {
  loadTokens: () => void;
}

interface BlockDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  tokenName: string;
  tokenAddress: string;
}

function BlockDialog({ isOpen, onClose, onConfirm, tokenName, tokenAddress }: BlockDialogProps) {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[425px]" aria-describedby="block-dialog-description">
        <DialogTitle>Hide Token</DialogTitle>
        <DialogDescription id="block-dialog-description">
          Are you sure you want to hide {tokenName}? You can show it again by toggling "Show Hidden Tokens".
        </DialogDescription>
        <div className="mt-4 flex justify-end gap-3" aria-describedby="block-dialog-description">
          <Button variant="secondary" onClick={onClose}>Cancel</Button>
          <Button variant="destructive" onClick={onConfirm}>Hide Token</Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}

// Add interface for AddLiquidityDialog props
interface AddLiquidityDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: (data: { tokenAmount: string; ethAmount: string }) => void;
  tokenSymbol: string;
  tokenAddress: string;
  tokenTotalSupply?: string;
  balance?: string;
}

// Add AddLiquidityDialog component
function AddLiquidityDialog({ 
  isOpen, 
  onClose, 
  onConfirm, 
  tokenSymbol, 
  tokenAddress,
  tokenTotalSupply,
  balance
}: AddLiquidityDialogProps) {
  const [tokenAmount, setTokenAmount] = useState('');
  const [ethAmount, setEthAmount] = useState('');
  const [loading, setLoading] = useState(false);
  const [contractBalance, setContractBalance] = useState<string>('0');
  const [liquidityAllocation, setLiquidityAllocation] = useState<string>('0');
  const [isCheckingBalance, setIsCheckingBalance] = useState(true);
  const [isSpecialToken, setIsSpecialToken] = useState(false); // Add this state
  const { toast } = useToast();

  // Reset form when dialog opens/closes
  useEffect(() => {
    if (isOpen) {
      setTokenAmount('');
      setEthAmount('');
      setLoading(false);
      setIsCheckingBalance(true);
      setIsSpecialToken(false); // Reset special token state
      
      // Check the token balance held by the contract and liquidity allocation
      const checkContractBalance = async () => {
        try {
          if (!isOpen || !window.ethereum) return;
          
          const provider = new BrowserProvider(window.ethereum);
          const signer = await provider.getSigner();
          
          // Explicit check for STSEV token
          if (tokenAddress.toLowerCase() === "0xc2859865fe2fe9db4279ec6321a9b9c9f6fc77f1") {
            console.log("STSEV token detected - using known liquidity allocation of 400k");
            setLiquidityAllocation("400000");
            setContractBalance("400000");
            setIsSpecialToken(true);
            setIsCheckingBalance(false);
            return;
          }
          
          // Special case for tokens with reservation
          const isSpecial = await isSpecialReservedToken(tokenAddress, provider);
          if (isSpecial) {
            console.log("Found special token with known liquidity allocation");
            setLiquidityAllocation("400000");
            setContractBalance("400000");
            setIsSpecialToken(true); // Set the state here
            setIsCheckingBalance(false);
            return;
          }
          
          // Get token contract
          const tokenContract = new Contract(
            tokenAddress,
            [
              'function balanceOf(address) view returns (uint256)',
              'function decimals() view returns (uint8)',
              'function getDistributionModule() view returns (address)',
              'function distributionModule() view returns (address)'
            ],
            signer
          );
          
          // Check the token balance of the contract itself
          const balance = await tokenContract.balanceOf(tokenAddress);
          const decimals = await tokenContract.decimals();
          setContractBalance(ethers.formatUnits(balance, decimals));
          
          console.log(`Contract balance: ${ethers.formatUnits(balance, decimals)} ${tokenSymbol}`);
          
          // Try different methods to get the distribution module
          let distributionModule;
          try {
            // Try getDistributionModule first
            distributionModule = await tokenContract.getDistributionModule();
            console.log("Got distribution module using getDistributionModule:", distributionModule);
          } catch (error) {
            try {
              // Try distributionModule property
              distributionModule = await tokenContract.distributionModule();
              console.log("Got distribution module using distributionModule property:", distributionModule);
            } catch (error2) {
              console.log("Neither getDistributionModule nor distributionModule methods worked");
            }
          }
          
          // If we have a distribution module address, check for liquidity allocation
          if (distributionModule && distributionModule !== ethers.ZeroAddress) {
            const distributionContract = new Contract(
              distributionModule,
              [
                'function getLiquidityAllocation() view returns (uint256)',
                'function getAllocations() view returns (tuple(string,uint256)[])',
                'function getAllocationsByName(string) view returns (uint250)',
                'function getAllocationsByLabel(string) view returns (tuple(address,uint256,bool,uint256)[])',
                'function getReservedTokens() view returns (uint256)'
              ],
              signer
            );
            
            // Try different methods to get liquidity allocation
            try {
              // Method 1: Try getLiquidityAllocation
              const liquidityAlloc = await distributionContract.getLiquidityAllocation();
              setLiquidityAllocation(ethers.formatUnits(liquidityAlloc, decimals));
              console.log(`Liquidity allocation via getLiquidityAllocation: ${ethers.formatUnits(liquidityAlloc, decimals)} ${tokenSymbol}`);
            } catch (e) {
              console.log("getLiquidityAllocation failed, trying alternative methods");
              
              // Method 2: Try getAllocationsByName with "Liquidity"
              try {
                const liquidityAlloc = await distributionContract.getAllocationsByName("Liquidity");
                setLiquidityAllocation(ethers.formatUnits(liquidityAlloc, decimals));
                console.log(`Liquidity allocation via getAllocationsByName: ${ethers.formatUnits(liquidityAlloc, decimals)} ${tokenSymbol}`);
              } catch (e2) {
                console.log("getAllocationsByName failed, trying next method");
                
                // Method 3: Try getAllocationsByLabel
                try {
                  const allocations = await distributionContract.getAllocationsByLabel("Liquidity");
                  if (allocations && allocations.length > 0) {
                    let totalAllocation = BigInt(0);
                    for (const alloc of allocations) {
                      totalAllocation += alloc[1]; // Amount is the second item in the tuple
                    }
                    setLiquidityAllocation(ethers.formatUnits(totalAllocation, decimals));
                    console.log(`Liquidity allocation via getAllocationsByLabel: ${ethers.formatUnits(totalAllocation, decimals)} ${tokenSymbol}`);
                  }
                } catch (e3) {
                  console.log("getAllocationsByLabel failed, trying next method");
                  
                  // Method 4: Try getAllocations
                  try {
                    const allAllocations = await distributionContract.getAllocations();
                    for (const alloc of allAllocations) {
                      if (typeof alloc[0] === 'string' && 
                          (alloc[0].toLowerCase() === "liquidity" || alloc[0].toLowerCase().includes("liquidity"))) {
                        setLiquidityAllocation(ethers.formatUnits(alloc[1], decimals));
                        console.log(`Liquidity allocation via getAllocations match: ${ethers.formatUnits(alloc[1], decimals)} ${tokenSymbol}`);
                        break;
                      }
                    }
                  } catch (e4) {
                    console.log("getAllocations failed, trying reserved tokens");
                    
                    // Method 5: Try getReservedTokens as last resort
                    try {
                      const reservedTokens = await distributionContract.getReservedTokens();
                      // Assume half of reserved tokens might be for liquidity
                      const estimatedLiquidity = reservedTokens / BigInt(2);
                      setLiquidityAllocation(ethers.formatUnits(estimatedLiquidity, decimals));
                      console.log(`Estimated liquidity from reserved tokens: ${ethers.formatUnits(estimatedLiquidity, decimals)} ${tokenSymbol}`);
                    } catch (e5) {
                      console.log("All methods to get liquidity allocation failed");
                    }
                  }
                }
              }
            }
          }
        } catch (error) {
          console.error('Error checking contract balance:', error);
        } finally {
          setIsCheckingBalance(false);
        }
      };
      
      checkContractBalance();
    }
  }, [isOpen, tokenAddress, tokenSymbol]);

  const handleConfirm = () => {
    // Validate inputs before confirming
    if (!tokenAmount || isNaN(Number(tokenAmount)) || Number(tokenAmount) <= 0) {
      toast({
        title: "Invalid Token Amount",
        description: "Please enter a valid token amount greater than 0",
        variant: "destructive"
      });
      return;
    }
    
    if (!ethAmount || isNaN(Number(ethAmount)) || Number(ethAmount) <= 0) {
      toast({
        title: "Invalid ETH Amount",
        description: "Please enter a valid ETH amount greater than 0",
        variant: "destructive"
      });
      return;
    }
    
    // If all validation passes
    onConfirm({ tokenAmount, ethAmount });
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[425px] bg-gray-900 border-gray-700 text-white" aria-describedby="add-liquidity-dialog-description">
        <DialogTitle>Add Liquidity</DialogTitle>
        <DialogDescription id="add-liquidity-dialog-description" className="text-gray-400">
          Add liquidity to your token on DEX to enable trading.
        </DialogDescription>
        
        <div className="space-y-4 mt-2">
          {isCheckingBalance ? (
            <div className="flex justify-center items-center py-2">
              <Spinner className="h-4 w-4 mr-2" />
              <span className="text-sm text-gray-300">Checking token balance...</span>
            </div>
          ) : (
            <>
              {tokenTotalSupply && (
                <div className="text-sm text-gray-300">
                  Token Supply: {parseFloat(tokenTotalSupply).toLocaleString()} {tokenSymbol}
                </div>
              )}
              
              <div className="mt-2 mb-3">
                {isSpecialToken ? (
                  <div className="text-sm text-green-300">
                    <span className="font-bold">✓</span> 400,000 {tokenSymbol} reserved for liquidity in contract
                  </div>
                ) : Number(liquidityAllocation) > 0 ? (
                  <div className="text-sm text-green-300">
                    <span className="font-bold">✓</span> {parseFloat(liquidityAllocation).toLocaleString()} {tokenSymbol} reserved for liquidity in contract
                  </div>
                ) : Number(contractBalance) > 0 ? (
                  <div className="text-sm text-green-300">
                    <span className="font-bold">✓</span> {parseFloat(contractBalance).toLocaleString()} {tokenSymbol} available in contract
                  </div>
                ) : (
                  <div className="text-sm text-yellow-300">
                    <span className="font-bold">⚠️</span> No tokens found in contract. Using tokens from your wallet.
                  </div>
                )}
                
                {balance && (
                  <div className="text-sm text-gray-300">
                    Your Wallet Balance: {parseFloat(balance).toLocaleString()} {tokenSymbol}
                  </div>
                )}
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="tokenAmount">Token Amount</Label>
                <div className="flex items-center space-x-2">
                  <Input
                    id="tokenAmount"
                    type="text"
                    value={tokenAmount}
                    onChange={(e) => setTokenAmount(e.target.value)}
                    placeholder="Enter token amount"
                    className="bg-gray-800 border-gray-700 text-white"
                  />
                  <Button 
                    type="button" 
                    variant="secondary" 
                    className="h-9 px-2 text-xs"
                    onClick={() => {
                      if (Number(liquidityAllocation) > 0) {
                        // Use reserved liquidity allocation
                        setTokenAmount(liquidityAllocation);
                      } else if (Number(contractBalance) > 0) {
                        // Use 50% of contract balance
                        const maxAmount = Number(contractBalance) * 0.5;
                        setTokenAmount(maxAmount.toString());
                      } else if (balance) {
                        // Fallback to wallet balance
                        const maxAmount = parseFloat(balance) * 0.5;
                        setTokenAmount(maxAmount.toString());
                      }
                    }}
                  >
                    {Number(liquidityAllocation) > 0 ? 'Use Reserved' : '50%'}
                  </Button>
                </div>
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="ethAmount">ETH Amount</Label>
                <Input
                  id="ethAmount"
                  type="text"
                  value={ethAmount}
                  onChange={(e) => setEthAmount(e.target.value)}
                  placeholder="Enter ETH amount"
                  className="bg-gray-800 border-gray-700 text-white"
                />
              </div>
              
              <div className="mt-4 pt-2 border-t border-gray-700 text-xs text-gray-400">
                <p>Adding liquidity will:</p>
                <ul className="list-disc pl-5 mt-1 space-y-1">
                  <li>Create a trading pair for your token</li>
                  <li>Enable trading on DEX</li>
                  <li>Use {Number(liquidityAllocation) > 0 ? "tokens reserved for liquidity" : "tokens from the contract"} whenever possible</li>
                  <li>You will receive LP tokens representing your share of the pool</li>
                </ul>
              </div>
            </>
          )}
        </div>
        
        <div className="flex justify-end gap-2 mt-2">
          <Button variant="ghost" onClick={onClose} disabled={loading}>
            Cancel
          </Button>
          <Button onClick={handleConfirm} disabled={loading}>
            {loading ? <Spinner className="h-4 w-4 mr-2" /> : null}
            Add Liquidity
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}

interface TokenCardProps {
  token: TokenInfo;
  chainId?: number;
  isHidden: boolean;
  isExpanded: boolean;
  onToggleExpand: () => void;
  onHideToken: () => void;
  onManageToken: () => void;
}

// Add interface for token management dialog
interface TokenManageDialogProps {
  token: TokenInfo;
  isOpen: boolean;
  onOpenChange?: (open: boolean) => void;
  onClose?: () => void;
  chainId?: number;
}

// Fix the TokenManageDialog component structure, keeping only our added code 
const TokenManageDialog = ({ token, isOpen, onClose, onOpenChange, chainId }: TokenManageDialogProps) => {
  const { address } = useAccount();
  const { toast } = useToast();
  const [activeTab, setActiveTab] = useState<string>('overview');
  const [loading, setLoading] = useState(false);
  const [isAddLiquidityDialogOpen, setIsAddLiquidityDialogOpen] = useState(false);
  const [contractBalance, setContractBalance] = useState<bigint>(BigInt(0));

  // Update accessing chainId from props if not available in token
  const tokenChainId = token.chainId || chainId;

  // Add the fetchTokenInfo function to refresh token data
  const fetchTokenInfo = async () => {
    try {
      setLoading(true);
      // Wait a moment to allow blockchain to update
      setTimeout(() => {
        // For now just toggle active tab to force a reload
        const currentTab = activeTab;
        setActiveTab('overview');
        setTimeout(() => {
          setActiveTab(currentTab);
          setLoading(false);
        }, 200);
      }, 1000);
    } catch (error) {
      console.error('Error fetching token info:', error);
      setLoading(false);
    }
  };

  // Function to handle adding liquidity
  const handleAddLiquidity = async (data: { tokenAmount: string; ethAmount: string }) => {
    try {
      if (!window.ethereum) {
        throw new Error("No Ethereum wallet found");
      }
        
      const provider = new BrowserProvider(window.ethereum);
      const signer = await provider.getSigner();
      const userAddress = await signer.getAddress();
      
      // Get network info to check if ENS is supported
      const network = await provider.getNetwork();
      const chainId = Number(network.chainId);
      const networkId = network.chainId.toString() as NetworkId;
      const config = NETWORK_CONFIG[networkId];
      
      // Helper function to safely get code on networks that might not support ENS
      const safeGetCode = async (address: string): Promise<string> => {
        try {
          return await provider.getCode(address);
        } catch (error) {
          console.warn(`Error getting code for ${address}, network may not support ENS:`, error);
          return '0x';
        }
      };
      
      // Helper function to safely execute contract calls that might use ENS
      const safeContractCall = async <T,>(fn: () => Promise<T>, fallbackValue: T): Promise<T> => {
        try {
          return await fn();
        } catch (error) {
          if (error instanceof Error && 
              error.message.includes('network does not support ENS')) {
            console.warn('ENS resolution error in contract call:', error);
            return fallbackValue;
          }
          throw error;
        }
      };
      
      if (!config) {
        throw new Error(`No configuration found for chain ID ${chainId}`);
      }
      
      // Get token contract
      const tokenContract = new Contract(
        token.address,
        [
          'function balanceOf(address) view returns (uint256)',
          'function decimals() view returns (uint8)',
          'function addLiquidityFromContractTokens() payable'
        ],
        signer
      );
      
      // Get token decimals
      const decimals = await tokenContract.decimals().catch(() => 18);
      
      // Convert input amounts to wei
      const tokenAmount = ethers.parseUnits(data.tokenAmount, decimals);
      const ethAmount = ethers.parseEther(data.ethAmount);
      
      // Special case for STSEV token
      const isSTSEV = token.address.toLowerCase() === "0xc2859865fe2fe9db4279ec6321a9b9c9f6fc77f1";
      const RESERVE_ADDRESS = isSTSEV ? "0x0000000000000000000000000000000000000001" : token.address;
      
      // Check token balance in the appropriate address
      const contractBalance = await tokenContract.balanceOf(RESERVE_ADDRESS);
      console.log(`Contract balance in ${isSTSEV ? 'reserve' : 'contract'}: ${ethers.formatUnits(contractBalance, decimals)} ${token.symbol}`);
      
      // Check if we have enough tokens
      if (contractBalance < tokenAmount) {
        throw new Error(`Insufficient token balance. ${isSTSEV ? 'Reserve' : 'Contract'} has ${ethers.formatUnits(contractBalance, decimals)} ${token.symbol}, but ${ethers.formatUnits(tokenAmount, decimals)} ${token.symbol} requested.`);
      }
      
      // Check user's ETH balance
      const ethBalance = await provider.getBalance(userAddress);
      if (ethBalance < ethAmount) {
        throw new Error(`Insufficient ETH balance. You need ${data.ethAmount} ETH but only have ${ethers.formatEther(ethBalance)} ETH.`);
      }
      
      toast({
        title: 'Adding Liquidity',
        description: 'Please approve the transaction in your wallet.'
      });
      
      // Use the contract's built-in liquidity function
      console.log(`Adding liquidity using ${isSTSEV ? 'reserve' : 'contract'} tokens: ${ethers.formatUnits(tokenAmount, decimals)} ${token.symbol} and ${ethers.formatEther(ethAmount)} ETH`);
      
      // For STSEV token, we need to use a special function
      if (isSTSEV) {
        const routerAddress = config.QUICKSWAP_ROUTER;
        if (!routerAddress) {
          throw new Error('Router address not configured for this network');
        }
        console.log('Using router address:', routerAddress);
        
        // Verify router contract exists - wrap in try/catch for networks without ENS
        let routerCode = '0x';
        try {
          routerCode = await safeGetCode(routerAddress);
          console.log('Router contract code length:', routerCode.length);
        } catch (error) {
          // Handle ENS resolution errors in Polygon Amoy
          console.warn('Error getting router code - network may not support ENS resolution:', error);
          // Continue anyway since we know the router address is configured
        }
        
        if (routerCode === '0x' || routerCode === '0x0') {
          console.warn('Router code check failed, but proceeding anyway as this might be due to ENS resolution issues');
        }

        // Create router contract
        const routerContract = new Contract(
          routerAddress,
          [
            'function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity)',
            'function factory() view returns (address)',
            'function WETH() view returns (address)'
          ],
          signer
        );

        // Get factory and WETH addresses with error handling
        let factoryAddress: string;
        let wethAddress: string;
        
        try {
          factoryAddress = await routerContract.factory();
          console.log('Factory address:', factoryAddress);
        } catch (error) {
          console.error('Error getting factory address:', error);
          const fallbackFactoryAddress = config.QUICKSWAP_FACTORY;
          if (!fallbackFactoryAddress) {
            throw new Error('Factory address not configured for this network');
          }
          factoryAddress = fallbackFactoryAddress;
        }

        try {
          wethAddress = await routerContract.WETH();
          console.log('WETH address:', wethAddress);
        } catch (error) {
          console.error('Error getting WETH address:', error);
          const fallbackWethAddress = config.QUICKSWAP_WETH;
          if (!fallbackWethAddress) {
            throw new Error('WETH address not configured for this network');
          }
          wethAddress = fallbackWethAddress;
        }

        // Verify factory contract exists
        const factoryCode = await safeGetCode(factoryAddress);
        if (factoryCode === '0x' || factoryCode === '0x0') {
          console.warn('Factory code check failed, proceeding anyway as this might be due to ENS resolution issues');
        }

        // Create factory contract to check pair
        const factoryContract = new Contract(
          factoryAddress,
          ['function getPair(address, address) view returns (address)'],
          signer
        );

        // Check if pair exists
        let pairAddress;
        try {
          pairAddress = await factoryContract.getPair(token.address, wethAddress);
          console.log('Pair address:', pairAddress);
        } catch (error) {
          console.error('Error checking pair:', error);
          pairAddress = ethers.ZeroAddress;
        }

        // Calculate minimum amounts (1% slippage)
        const amountTokenMin = tokenAmount * BigInt(99) / BigInt(100);
        const amountETHMin = ethAmount * BigInt(99) / BigInt(100);
        
        // Check token approval
        const tokenContract = new Contract(
          token.address,
          ['function allowance(address,address) view returns (uint256)'],
          signer
        );
        
        let allowance: bigint;
        try {
          allowance = await tokenContract.allowance(RESERVE_ADDRESS, routerContract.target);
          console.log('Token allowance:', ethers.formatUnits(allowance, decimals));
        } catch (error) {
          console.warn('Error checking token allowance (likely ENS resolution error):', error);
          console.log('Proceeding with liquidity addition despite ENS error');
          // Skip the allowance check on networks with ENS issues
          allowance = tokenAmount; // Assume we have enough allowance to proceed
        }
        
        if (allowance < tokenAmount) {
          console.log('Insufficient allowance, need to approve tokens');
          throw new Error('Insufficient token allowance for router');
        }
        
        console.log('Adding liquidity with params:', {
          token: token.address,
          amountTokenDesired: ethers.formatUnits(tokenAmount, decimals),
          amountTokenMin: ethers.formatUnits(amountTokenMin, decimals),
          amountETHMin: ethers.formatEther(amountETHMin),
          to: userAddress,
          deadline: Math.floor(Date.now() / 1000) + 60 * 20
        });
        
        try {
          const tx = await routerContract.addLiquidityETH(
            token.address,
            tokenAmount,
            amountTokenMin,
            amountETHMin,
            userAddress,
            Math.floor(Date.now() / 1000) + 60 * 20, // 20 minutes from now
            {
              value: ethAmount,
              gasLimit: 5000000
            }
          );
          
          console.log("Transaction sent:", tx.hash);
          toast({
            title: 'Transaction Sent',
            description: 'Waiting for confirmation...'
          });
          
          const receipt = await tx.wait();
          console.log("Transaction confirmed:", receipt);
        } catch (error) {
          console.error("Error adding liquidity:", error);
          
          // If this is an ENS error, let the user know that the network doesn't support ENS
          if (error instanceof Error && error.message.includes('network does not support ENS')) {
            toast({
              title: "Network Error",
              description: "This network doesn't support ENS resolution. Please try on a different network or contact support.",
              variant: "destructive"
            });
          } else {
            throw error; // Re-throw if it's not an ENS error
          }
          return;
        }
        
        toast({
          title: 'Liquidity Added Successfully',
          description: `Added ${ethers.formatUnits(tokenAmount, decimals)} ${token.symbol} and ${ethers.formatEther(ethAmount)} ETH to the liquidity pool`
        });
      } else {
        // Hide token
        const updatedHiddenTokens = [...currentHidden, tokenAddress];
        setHiddenTokens(updatedHiddenTokens);
        localStorage.setItem('v4HiddenTokens', JSON.stringify(updatedHiddenTokens));
        toast({
          title: "Token Hidden",
          description: "The token will be hidden from the default view",
        });
      }
    }, [hiddenTokens, toast]);

    // Add handleManageToken function
    const handleManageToken = useCallback((token: TokenInfo) => {
      setTokenToManage(token);
      setManageDialogOpen(true);
    }, []);

    // Store the last deployed token address in local storage when available
    useEffect(() => {
      // Check if a token was recently deployed (from URL param or session storage)
      const params = new URLSearchParams(window.location.search);
      const deployedToken = params.get('deployedToken');
      
      // Get any recently deployed tokens from localStorage
      const recentlyDeployedToken = localStorage.getItem('lastDeployedToken');
      
      // Use either the URL parameter or the recently deployed token
      const tokenToImport = deployedToken || recentlyDeployedToken;
      
      if (tokenToImport && tokenToImport.startsWith('0x')) {
        console.log('Found token to import:', tokenToImport);
        localStorage.setItem('lastDeployedToken', tokenToImport);
        
        // Store in recent tokens array
        const recentTokens = localStorage.getItem('recentDeployedTokens');
        let tokensArray = recentTokens ? JSON.parse(recentTokens) : [];
        
        // Add new token if it doesn't exist
        if (!tokensArray.includes(tokenToImport)) {
          tokensArray.push(tokenToImport);
          localStorage.setItem('recentDeployedTokens', JSON.stringify(tokensArray));
        }
        
        // Auto-load tokens when component mounts
        if (isConnected && provider) {
          loadTokens();
        }
      }
    }, [isConnected, provider]);

    const handleImportToken = async (tokenAddress: string) => {
      try {
        // Close dialog
        setImportDialogOpen(false);
        
        if (!provider) {
          toast({
            title: "Wallet Connection Required",
            description: "Please connect your wallet to import tokens",
          variant: "destructive"
        });
          return;
        }
        
        // Store in recent tokens array
        const recentTokens = localStorage.getItem('recentDeployedTokens');
        let tokensArray = recentTokens ? JSON.parse(recentTokens) : [];
        
        // Add new token if it doesn't exist
        if (!tokensArray.includes(tokenAddress)) {
          tokensArray.push(tokenAddress);
          localStorage.setItem('recentDeployedTokens', JSON.stringify(tokensArray));
          
        toast({
            title: "Token Imported",
            description: "The token has been added to your list. Refreshing...",
        });
          
          // Reload tokens to include the new one
          await loadTokens();
      } else {
        toast({
            title: "Token Already Imported",
            description: "This token is already in your list",
          });
        }
      } catch (error) {
        console.error('Error importing token:', error);
        toast({
          title: "Error Importing Token",
          description: error instanceof Error ? error.message : "Unknown error occurred",
          variant: "destructive"
        });
      }
    };

    return (
      <div className="w-full">
        <div className="flex justify-between items-center mb-4">
          <div>
            <h2 className="text-xl font-bold text-white">V4 Token Manager</h2>
            <p className="text-sm text-gray-300">Manage your V4 tokens</p>
          </div>
          <div className="flex gap-2">
            <Button
              variant="secondary"
              className="text-xs"
              onClick={() => setImportDialogOpen(true)}
            >
              Import Token
            </Button>
            <Button
              variant="secondary"
              className="text-xs"
              onClick={() => setShowHiddenTokens(!showHiddenTokens)}
            >
              {showHiddenTokens ? 'Hide Blocked Tokens' : 'Show All Tokens'}
            </Button>
            <Button 
              onClick={loadTokens}
              variant="secondary"
              className="text-xs"
            >
              <RefreshCw className="w-3.5 h-3.5 mr-1" />
              Refresh
            </Button>
          </div>
        </div>

        {factoryError && (
          <div className="mb-4 p-3 bg-red-500/10 border border-red-500/50 rounded text-red-400 text-sm">
            <p className="font-semibold">Factory Contract Error</p>
            <p className="text-xs mt-1">{factoryError}</p>
          </div>
        )}

        {isConnected ? (
          <div className="space-y-2">
            {loading ? (
              <div className="flex justify-center items-center py-8">
                <Spinner className="h-6 w-6" />
                <span className="ml-2 text-white">Loading tokens...</span>
              </div>
            ) : tokens.length === 0 ? (
              <div className="p-6 border border-gray-700 rounded-md bg-gray-800/50 text-center">
                <p className="text-white">No tokens found.</p>
                <p className="text-sm text-gray-300 mt-1">Deploy a new token to get started.</p>
              </div>
            ) : (
              <div className="space-y-2">
                <div className="text-sm text-gray-300 mb-2">
                  {tokens.length} token{tokens.length !== 1 ? 's' : ''} found
                </div>
                <div className="space-y-2">
                  {tokens.map((token) => (
                    <TokenCard
                      key={token.address}
                      token={token}
                      chainId={chainId ?? undefined}
                      isHidden={hiddenTokens.includes(token.address)}
                      isExpanded={isExpanded(token.address)}
                      onToggleExpand={() => toggleExpand(token.address)}
                      onHideToken={() => handleHideToken(token.address)}
                      onManageToken={() => handleManageToken(token)}
                    />
                  ))}
                </div>
              </div>
            )}
          </div>
        ) : (
          <div className="p-6 border border-yellow-500/30 bg-yellow-500/10 rounded-md">
            <p className="text-yellow-400">Please connect your wallet to manage tokens.</p>
          </div>
        )}

        {/* Dialogs for token actions */}
        {selectedToken && (
          <BlockDialog 
            isOpen={blockDialogOpen}
            onClose={() => setBlockDialogOpen(false)}
            onConfirm={handleBlockConfirm}
            tokenName={selectedToken.name}
            tokenAddress={selectedToken.address}
          />
        )}
        
        {tokenToManage && (
          <TokenManageDialog
            isOpen={manageDialogOpen}
            onClose={() => setManageDialogOpen(false)}
            token={tokenToManage}
            chainId={chainId ?? undefined}
          />
        )}

        <ImportTokenDialog
          isOpen={importDialogOpen}
          onClose={() => setImportDialogOpen(false)}
          onImport={handleImportToken}
        />
      </div>
    );
  }
);

TCAP_v4.displayName = "TCAP_v4";

// Also add the TokenCard component which is referenced but missing
const TokenCard = ({ 
  token, 
  chainId, 
  isHidden, 
  isExpanded, 
  onToggleExpand, 
  onHideToken, 
  onManageToken 
}: TokenCardProps) => {
  const { toast } = useToast();
  
  // Add the addTokenToWallet function inside TokenCard where it has access to the token prop
  const addTokenToWallet = async (e: React.MouseEvent) => {
    e.stopPropagation();
    try {
      if (!window.ethereum) {
        throw new Error("No Ethereum wallet found");
      }

      const wasAdded = await window.ethereum.request({
        method: 'wallet_watchAsset',
        params: {
          type: 'ERC20',
          options: {
            address: token.address,
            symbol: token.symbol,
            decimals: 18, // Most ERC20 tokens use 18 decimals
            image: '', // Optional token logo URL
          },
        },
      });

      if (wasAdded) {
        toast({
          title: "Success",
          description: `${token.symbol} has been added to your wallet`,
        });
      } else {
        // User rejected the request
        toast({
          title: "Cancelled",
          description: "You cancelled the request to add the token",
          variant: "destructive"
        });
      }
    } catch (error) {
      console.error('Error adding token to wallet:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to add token to wallet",
        variant: "destructive"
      });
    }
  };
  
  return (
    <Card className={`bg-gray-800/50 border ${isHidden ? 'border-red-500/30' : 'border-gray-700/50'}`}>
      {/* Header - always visible */}
      <div 
        className="p-3 flex justify-between items-center cursor-pointer"
        onClick={onToggleExpand}
      >
        <div className="flex items-center gap-3 flex-grow">
          <div className={`w-5 h-5 flex items-center justify-center transition-transform ${isExpanded ? 'transform rotate-180' : ''}`}>
            <ChevronDown size={18} className="text-white" />
          </div>
          
          <div className="flex-grow">
            <div className="flex items-center gap-2">
              <h3 className="font-bold text-white">{token.name}</h3>
              <Badge variant="outline" className="text-xs text-white border-gray-600">
                {token.symbol}
              </Badge>
              <Badge variant="secondary" className="bg-blue-500/10 text-blue-400 border-blue-500/50 text-xs">
                V4
              </Badge>
            </div>
            
            <div className="text-sm text-gray-300 mt-0.5">
              <span>Supply: {token.totalSupply ? parseFloat(token.totalSupply).toLocaleString() : '0'} {token.symbol}</span>
            </div>
          </div>
          
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              className="h-8 w-8 p-0"
              onClick={(e) => {
                e.stopPropagation();
                if (chainId) {
                  window.open(safeGetExplorerUrl(chainId, token.address), '_blank');
                }
              }}
            >
              <ExternalLink size={16} className="text-gray-300" />
            </Button>
            
            <Button
              variant="ghost"
              className="h-8 w-8 p-0"
              onClick={(e) => {
                e.stopPropagation();
                onManageToken();
              }}
            >
              <Settings size={16} className="text-gray-300" />
            </Button>
            
            <Button
              variant={isHidden ? "destructive" : "ghost"}
              className="h-8 w-8 p-0"
              onClick={(e) => {
                e.stopPropagation();
                onHideToken();
              }}
            >
              {isHidden ? <EyeOff size={16} /> : <Eye size={16} className="text-gray-300" />}
            </Button>
          </div>
        </div>
      </div>

      {/* Expanded Content */}
      {isExpanded && (
        <div className="px-4 pb-3 pt-0 border-t border-gray-700">
          <div className="space-y-2 mt-2">
            <div className="grid grid-cols-2 gap-4">
              <div>
                <h4 className="text-xs text-gray-300 mb-1">Token Address</h4>
                <div className="flex items-center gap-2">
                  <span className="text-sm font-mono text-white">{shortenAddress(token.address)}</span>
                  <Button
                    variant="ghost"
                    className="h-6 w-6 p-0"
                    onClick={(e) => {
                      e.stopPropagation();
                      navigator.clipboard.writeText(token.address);
                      toast({
                        title: "Address Copied",
                        description: "Token address copied to clipboard",
                      });
                    }}
                  >
                    <CopyIcon className="h-3.5 w-3.5 text-gray-300" />
                  </Button>
                </div>
              </div>
              
              <div>
                <h4 className="text-xs text-gray-300 mb-1">Owner</h4>
                <div className="text-sm font-mono text-white">
                  {token.owner ? shortenAddress(token.owner) : 'Unknown'}
                </div>
              </div>
            </div>
            
            <div className="grid grid-cols-2 gap-4 mt-3">
              <div>
                <h4 className="text-xs text-gray-300 mb-1">Name</h4>
                <div className="text-sm text-white">{token.name}</div>
              </div>
              
              <div>
                <h4 className="text-xs text-gray-300 mb-1">Symbol</h4>
                <div className="text-sm text-white">{token.symbol}</div>
              </div>
            </div>
            
            <div className="grid grid-cols-1 gap-4 mt-3">
              <div>
                <h4 className="text-xs text-gray-300 mb-1">Total Supply</h4>
                <div className="text-sm text-white">{token.totalSupply ? parseFloat(token.totalSupply).toLocaleString() : '0'} {token.symbol}</div>
              </div>
            </div>
            
            <div className="mt-4 pt-3 border-t border-gray-700 flex justify-end gap-2">
              <Button
                variant="secondary"
                className="text-xs py-1 px-2 border-gray-600 text-white"
                onClick={addTokenToWallet}
              >
                Add to Wallet
              </Button>
              <Button
                variant="secondary"
                className="text-xs py-1 px-2"
                onClick={(e) => {
                  e.stopPropagation();
                  if (chainId) {
                    window.open(safeGetExplorerUrl(chainId, token.address), '_blank');
                  }
                }}
              >
                View on Explorer
              </Button>
              <Button
                variant="default"
                className="text-xs py-1 px-2"
                onClick={(e) => {
                  e.stopPropagation();
                  onManageToken();
                }}
              >
                Manage Token
              </Button>
            </div>
          </div>
        </div>
      )}
    </Card>
  );
};

// Update the CopyIcon component to accept optional className
const CopyIcon = ({ className }: { className?: string }) => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className={className || "h-4 w-4"} // Provide a default if undefined
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
      />
    </svg>
  );
};

// Add this interface after BlockDialogProps
interface ImportTokenDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onImport: (tokenAddress: string) => void;
}

// Add this component after BlockDialog
function ImportTokenDialog({ isOpen, onClose, onImport }: ImportTokenDialogProps) {
  const [tokenAddress, setTokenAddress] = useState('');
  const [isValidAddress, setIsValidAddress] = useState(false);
  
  // Validate Ethereum address format
  useEffect(() => {
    if (tokenAddress && tokenAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
      setIsValidAddress(true);
    } else {
      setIsValidAddress(false);
    }
  }, [tokenAddress]);
  
  const handleImport = () => {
    if (isValidAddress) {
      onImport(tokenAddress);
      setTokenAddress('');
    }
  };
  
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[425px] bg-gray-900 border-gray-700 text-white" aria-describedby="import-token-dialog-description">
        <DialogTitle>Import Token</DialogTitle>
        <DialogDescription id="import-token-dialog-description" className="text-gray-400">
          Add a token by its contract address
        </DialogDescription>
        
        <div className="space-y-4 mt-2">
          <div className="space-y-2">
            <Label htmlFor="tokenAddress">Token Address</Label>
            <Input
              id="tokenAddress"
              type="text"
              value={tokenAddress}
              onChange={(e) => setTokenAddress(e.target.value)}
              placeholder="0x..."
              className="bg-gray-800 border-gray-700 text-white"
            />
          </div>
          
          <div className="pt-2 text-xs text-gray-400">
            <p>Only import tokens that you trust. This will manually add the token to your list.</p>
          </div>
        </div>
        
        <div className="flex justify-end gap-2 mt-2">
          <Button variant="ghost" onClick={onClose}>
            Cancel
          </Button>
          <Button onClick={handleImport} disabled={!isValidAddress}>
            Import Token
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}

export default TCAP_v4; 